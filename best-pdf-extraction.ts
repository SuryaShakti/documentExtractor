// Best PDF extraction solution using multiple proven libraries\n// Install these packages:\n// npm install pdfjs-dist pdf2pic tesseract.js\n\nimport OpenAI from 'openai';\n\nconst openai = new OpenAI({\n  apiKey: process.env.OPENAI_API_KEY,\n});\n\n// Method 1: PDF.js (Mozilla) - Best for text-based PDFs\nasync function extractWithPDFJS(buffer: Buffer, column: any) {\n  try {\n    console.log('üî• Trying PDF.js (Mozilla) - industry standard...');\n    \n    const pdfjsLib = await import('pdfjs-dist/legacy/build/pdf.js');\n    \n    // Configure PDF.js for server-side\n    pdfjsLib.GlobalWorkerOptions.workerSrc = null; // Disable worker for server-side\n    \n    const pdf = await pdfjsLib.getDocument({\n      data: new Uint8Array(buffer),\n      useWorkerFetch: false,\n      isEvalSupported: false,\n      useSystemFonts: true,\n      disableFontFace: true,\n      nativeImageDecoderSupport: 'none'\n    }).promise;\n    \n    console.log('‚úÖ PDF loaded successfully, pages:', pdf.numPages);\n    \n    const textContent = [];\n    const maxPages = Math.min(pdf.numPages, 10); // Process max 10 pages\n    \n    for (let pageNum = 1; pageNum <= maxPages; pageNum++) {\n      try {\n        const page = await pdf.getPage(pageNum);\n        const content = await page.getTextContent();\n        \n        const pageText = content.items\n          .map((item: any) => item.str || '')\n          .filter(text => text.trim().length > 0)\n          .join(' ');\n        \n        if (pageText.trim()) {\n          textContent.push(pageText);\n          console.log(`üìÑ Page ${pageNum}: ${pageText.length} chars`);\n        }\n      } catch (pageError) {\n        console.log(`‚ö†Ô∏è Page ${pageNum} failed:`, pageError.message);\n      }\n    }\n    \n    const fullText = textContent.join('\\n\\n');\n    \n    if (fullText.length > 100) {\n      console.log('üéâ PDF.js SUCCESS!');\n      console.log('üìä Total text length:', fullText.length);\n      console.log('üìù Preview:', fullText.substring(0, 200));\n      \n      return await processWithOpenAI(fullText, column, 'pdfjs-extraction');\n    } else {\n      throw new Error('Insufficient text extracted with PDF.js');\n    }\n    \n  } catch (error) {\n    console.log('‚ùå PDF.js failed:', error.message);\n    throw error;\n  }\n}\n\n// Method 2: PDF2Pic + Tesseract OCR - Best for scanned/image PDFs\nasync function extractWithOCR(buffer: Buffer, column: any) {\n  try {\n    console.log('üîç Trying PDF2Pic + Tesseract OCR...');\n    \n    const pdf2pic = require('pdf2pic');\n    const Tesseract = require('tesseract.js');\n    \n    // Convert PDF to images\n    const convert = pdf2pic.fromBuffer(buffer, {\n      density: 200,           // High quality\n      saveFilename: 'page',\n      savePath: '/tmp',       // Temp directory\n      format: 'png',\n      width: 2000,\n      height: 2000\n    });\n    \n    console.log('üñºÔ∏è Converting PDF to images...');\n    const images = [];\n    const maxPages = 3; // OCR first 3 pages (OCR is slower)\n    \n    for (let page = 1; page <= maxPages; page++) {\n      try {\n        const result = await convert(page, { responseType: 'buffer' });\n        images.push(result.buffer);\n        console.log(`üì∑ Page ${page} converted to image`);\n      } catch (pageError) {\n        console.log(`‚ö†Ô∏è Page ${page} conversion failed:`, pageError.message);\n        break; // Stop if conversion fails\n      }\n    }\n    \n    if (images.length === 0) {\n      throw new Error('No images converted from PDF');\n    }\n    \n    console.log('üî§ Running OCR on images...');\n    const ocrTexts = [];\n    \n    for (let i = 0; i < images.length; i++) {\n      try {\n        const { data: { text } } = await Tesseract.recognize(images[i], 'eng', {\n          logger: () => {} // Suppress OCR logs\n        });\n        \n        if (text.trim().length > 20) {\n          ocrTexts.push(text.trim());\n          console.log(`üìù Page ${i + 1} OCR: ${text.length} chars`);\n        }\n      } catch (ocrError) {\n        console.log(`‚ö†Ô∏è Page ${i + 1} OCR failed:`, ocrError.message);\n      }\n    }\n    \n    const fullText = ocrTexts.join('\\n\\n');\n    \n    if (fullText.length > 50) {\n      console.log('üéâ OCR SUCCESS!');\n      console.log('üìä Total OCR text:', fullText.length);\n      console.log('üìù Preview:', fullText.substring(0, 200));\n      \n      return await processWithOpenAI(fullText, column, 'ocr-extraction');\n    } else {\n      throw new Error('Insufficient text from OCR');\n    }\n    \n  } catch (error) {\n    console.log('‚ùå OCR failed:', error.message);\n    throw error;\n  }\n}\n\n// Method 3: Poppler PDF Utils (if available)\nasync function extractWithPoppler(buffer: Buffer, column: any) {\n  try {\n    console.log('üìö Trying Poppler PDF utils...');\n    \n    const { exec } = require('child_process');\n    const fs = require('fs').promises;\n    const path = require('path');\n    \n    // Write buffer to temp file\n    const tempPath = `/tmp/pdf_${Date.now()}.pdf`;\n    await fs.writeFile(tempPath, buffer);\n    \n    // Use pdftotext command (if available)\n    const textPath = `/tmp/text_${Date.now()}.txt`;\n    \n    await new Promise((resolve, reject) => {\n      exec(`pdftotext \"${tempPath}\" \"${textPath}\"`, (error) => {\n        if (error) {\n          reject(new Error('pdftotext not available'));\n        } else {\n          resolve(true);\n        }\n      });\n    });\n    \n    const extractedText = await fs.readFile(textPath, 'utf8');\n    \n    // Cleanup\n    await fs.unlink(tempPath).catch(() => {});\n    await fs.unlink(textPath).catch(() => {});\n    \n    if (extractedText.length > 100) {\n      console.log('üéâ Poppler SUCCESS!');\n      console.log('üìä Total text:', extractedText.length);\n      \n      return await processWithOpenAI(extractedText, column, 'poppler-extraction');\n    } else {\n      throw new Error('Insufficient text from Poppler');\n    }\n    \n  } catch (error) {\n    console.log('‚ùå Poppler failed:', error.message);\n    throw error;\n  }\n}\n\n// Process extracted text with OpenAI\nasync function processWithOpenAI(text: string, column: any, method: string) {\n  console.log(`ü§ñ Processing with OpenAI (${method})...`);\n  \n  const completion = await openai.chat.completions.create({\n    model: \"gpt-4o\",\n    messages: [\n      {\n        role: \"system\",\n        content: \"You are a professional document data extraction AI. Extract specific information from document text with high accuracy. Always respond with valid JSON format.\"\n      },\n      {\n        role: \"user\",\n        content: `Document Text:\\n${text.substring(0, 20000)}\\n\\nExtraction Task:\\n- Field: ${column.name}\\n- Prompt: ${column.prompt}\\n- Type: ${column.type}\\n\\nInstructions:\\n- Extract the exact information requested\\n- Be precise and accurate\\n- If information not found, return empty value with confidence 0\\n\\nReturn JSON: {\"value\": \"extracted_data\", \"confidence\": 0.95}`\n      }\n    ],\n    temperature: 0.1,\n    max_tokens: 1000,\n    response_format: { type: \"json_object\" }\n  });\n\n  const response = completion.choices[0].message.content;\n  console.log(`üéØ OpenAI response:`, response);\n\n  const parsedResponse = JSON.parse(response || '{\"value\":\"\",\"confidence\":0}');\n  \n  return {\n    columnId: column.id,\n    value: parsedResponse.value || \"\",\n    confidence: Math.min(Math.max(parsedResponse.confidence || 0, 0), 1),\n    extractedBy: {\n      method: \"ai\",\n      model: \"gpt-4o\",\n      version: method,\n    },\n  };\n}\n\n// Main extraction function with multiple fallbacks\nexport async function extractFromPDF(buffer: Buffer, column: any) {\n  console.log('üöÄ Starting BEST PDF extraction with multiple methods...');\n  \n  const methods = [\n    { name: 'PDF.js', fn: extractWithPDFJS },\n    { name: 'OCR', fn: extractWithOCR },\n    { name: 'Poppler', fn: extractWithPoppler }\n  ];\n  \n  for (const method of methods) {\n    try {\n      console.log(`\\nüîÑ Attempting ${method.name}...`);\n      const result = await method.fn(buffer, column);\n      console.log(`‚úÖ ${method.name} SUCCEEDED!`);\n      return result;\n    } catch (error) {\n      console.log(`‚ùå ${method.name} failed:`, error.message);\n      continue;\n    }\n  }\n  \n  // All methods failed - return helpful error\n  console.log('üíî All extraction methods failed');\n  \n  return {\n    columnId: column.id,\n    value: \"All PDF extraction methods failed. PDF may be corrupted, heavily encrypted, or use unsupported format. Please try manual extraction or contact support.\",\n    confidence: 0,\n    extractedBy: {\n      method: \"ai\",\n      model: \"gpt-4o\",\n      version: \"all-methods-failed\",\n    },\n  };\n}\n\n// Export for use in main route\nexport default extractFromPDF;\n